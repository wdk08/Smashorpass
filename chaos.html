<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Balance of the Gauntlet</title>
<style>
body {
  background:#111;
  color:#fff;
  font-family:sans-serif;
  text-align:center;
  padding:20px;
}
a { color:#0af; text-decoration:none; margin:0 10px; }
a:hover { text-decoration:underline; }

.card {
  width:260px;
  background:#1a1a1a;
  border:2px solid #444;
  border-radius:14px;
  padding:10px;
  margin:20px auto;
}
.card img {
  width:100%;
  height:300px;
  object-fit:cover;
  border-radius:12px;
}
.buttons button {
  padding:10px 20px;
  font-size:18px;
  margin:10px;
  border:none;
  border-radius:10px;
  cursor:pointer;
}
.keep { background:#28a745; color:white; }
.delete { background:#dc3545; color:white; }

/* Stones */
.stones {
  display:flex;
  justify-content:center;
  gap:15px;
  margin:20px 0;
}
.stone-btn {
  padding:10px 14px;
  border-radius:8px;
  border:none;
  cursor:pointer;
  font-weight:bold;
  font-size:16px;
}
#time {background:#aaa;color:#000;}
#soul {background:#800;color:#fff;}
#space {background:#08f;color:#fff;}
#reality {background:#0a0;color:#fff;}

#lists {
  display: flex;
  justify-content: space-between;
  max-width: 900px;
  margin: 20px auto;
  gap: 20px;
}
.list {
  width: 45%;
  background: #1a1a1a;
  border: 2px solid #333;
  border-radius: 12px;
  padding: 10px;
  max-height: 300px;
  overflow-y: auto;
}
.list h3 {
  margin-top: 0;
  border-bottom: 1px solid #333;
  padding-bottom: 5px;
}
.list ul { list-style: none; padding:0; margin:0;}
.list li {
  font-size:14px;
  padding:4px 0;
  border-bottom:1px solid #222;
  cursor:pointer;
}
.list li.protected::after {
  content: " üõ°Ô∏è";
}
.list li.temp-protected::after {
  content: " üõ°Ô∏è";
  opacity: 0.7;
}

.list li.highlight { background:#0af22f; }

.instructions {
  max-width:800px;
  margin:40px auto;
  text-align:left;
  background:#1a1a1a;
  padding:20px;
  border-radius:12px;
  border:2px solid #333;
}
</style>
</head>
<body>
<h1>üß§ Balance of the Gauntlet</h1>
<a href="index.html">Smash or Pass</a>
  <a href="kmk.html">Play Kiss Marry Kill</a>
  <a href="goc.html">Play Girl or Car</a>
  <a href="blind.html">Play Blind Ranking</a>
  <a href="wyw.html">Play King of the Hill</a>
    <a href="chaos.html">Infinity War</a>
    <a href="fb.html">Football Lineup</a>
<br><br>

<div class="stones">
  <button class="stone-btn" id="time">‚è≥ Time Stone</button>
  <button class="stone-btn" id="soul">üíÄ Soul Stone</button>
  <button class="stone-btn" id="space">üåå Space Stone</button>
  <button class="stone-btn" id="reality">ü™û Reality Stone</button>
</div>

<div id="lists">
  <div class="list keep-list">
    <h3>‚úÖ Keep</h3>
    <ul id="keepList"></ul>
  </div>
  <div class="list gone-list">
    <h3>‚ùå Gone</h3>
    <ul id="goneList"></ul>
  </div>
</div>

<div id="game">
  <div class="card">
    <h2 id="name">Loading...</h2>
    <img id="img" src="">
  </div>
  <div class="buttons">
    <button class="keep" onclick="keep()">Keep</button>
    <button class="delete" onclick="remove()">Delete</button>
  </div>
</div>

<script>
let pool = [];
let keepList = [];
let gone = [];
let selectingFor = null; // "space", "reality", "soul"
let current = null;
let round = 0;
const MAX_KEEP = 12;
const GAUNTLET_CHANCE = 0.25;      
const INSTANT_SNAP_CHANCE = 0.35;  

// Stone usage tracking
let stonesUsed = {time:false,soul:false,space:false,reality:false};
let spaceProtected = null;
let lastSnap = [];

fetch("people.json")
  .then(r=>r.json())
  .then(data=>{
    pool = Object.entries(data.Female)
      .map(([name,img])=>({name,img}))
      .sort(()=>Math.random()-0.5);
    next();
  });

function renderLists(){
  const keepUl = document.getElementById("keepList");
keepUl.innerHTML = keepList.map(p=>{
  let cls = "";
  if(p.protected) cls = "protected";
  if(p.tempProtected) cls = "temp-protected";
  return `<li data-name="${p.name}" class="${cls}">${p.name}</li>`;
}).join("");
  const goneUl = document.getElementById("goneList");
  goneUl.innerHTML = gone.map(p=>`<li data-name="${p.name}">${p.name}</li>`).join("");
}

function maybeGauntlet(){
  if(pool.length===0) return;
  if(Math.random() < GAUNTLET_CHANCE && keepList.length>2){
    if(Math.random() < INSTANT_SNAP_CHANCE) instantSnap();
    else snapPrompt();
  }
}

function next(){
  if(pool.length===0){
    endGame();
    return;
  }
  round++;
  current = pool.pop();
  document.getElementById("name").textContent = current.name;
  document.getElementById("img").src = current.img || "";
}

function keep(){
  if(keepList.length >= MAX_KEEP){
    const idx = Math.floor(Math.random()*keepList.length);
    const victim = keepList.splice(idx,1)[0];
    gone.push(victim);
    alert(`Max keep reached! ${victim.name} was sacrificed.`);
  }
  keepList.push({...current,protected:false});
  renderLists();
  maybeGauntlet();
  next();
}
function remove(){
  gone.push(current);
  renderLists();
  maybeGauntlet();
  next();
}

// SNAP logic
function snapPrompt(){
  const toRemove = keepList.filter(p => !p.protected && !p.tempProtected);
  lastSnap = [...toRemove];

  const count = Math.ceil(toRemove.length / 2);
  const snapped = toRemove.splice(0, count);

  keepList = keepList.filter(p => p.protected || p.tempProtected).concat(toRemove);
  gone.push(...snapped);

  // üî• Space Stone only lasts ONE snap
  keepList.forEach(p => p.tempProtected = false);

  renderLists();
  alert(`üí• Snap! Half of unprotected keeps were erased (${count}).`);
}


// Instant Snap
function instantSnap(){
  const toRemove = keepList.filter(p => !p.protected && !p.tempProtected);
  if(toRemove.length < 2) return;

  shuffle(toRemove);
  const count = Math.ceil(toRemove.length / 2);
  const snapped = toRemove.splice(0, count);

  keepList = keepList.filter(p => p.protected || p.tempProtected).concat(toRemove);
  gone.push(...snapped);

  // üî• Space Stone expires here
  keepList.forEach(p => p.tempProtected = false);

  renderLists();
  alert(`üí• SNAP! ${count} were erased.`);
}


// Stones
document.getElementById("time").addEventListener("click",()=>{
  if(stonesUsed.time) return alert("‚è≥ Time Stone already used!");
  stonesUsed.time = true;
  const restore = lastSnap.slice(0,Math.ceil(lastSnap.length/2));
  keepList.push(...restore.map(p=>({...p,protected:false})));
  renderLists();
  alert(`‚è≥ Time Stone used! ${restore.length} restored from last snap.`);
});

document.getElementById("soul").addEventListener("click",()=>{
  if(stonesUsed.soul) return alert("üíÄ Soul Stone already used!");
  stonesUsed.soul = true;
  highlightKeep("soul");
});

document.getElementById("space").addEventListener("click",()=>{
  if(stonesUsed.space) return alert("üåå Space Stone already used!");
  stonesUsed.space = true;
  highlightKeep("space");
});

document.getElementById("reality").addEventListener("click",()=>{
  if(stonesUsed.reality) return alert("ü™û Reality Stone already used!");
  stonesUsed.reality = true;
  highlightGone();
});

// Highlight functions
function highlightKeep(stone){
  const lis = document.querySelectorAll("#keepList li");
  lis.forEach(li=>li.classList.add("highlight"));
  lis.forEach(li=>li.onclick=function(){
    const name = this.dataset.name;
    const idx = keepList.findIndex(p=>p.name===name);
if(stone === "space"){
  keepList[idx].tempProtected = true; // TEMP protection
  alert(`${name} is protected from the next snap üõ°Ô∏è`);


    } else if(stone==="soul"){
      const removed = keepList.splice(idx,1)[0];
      gone.push(removed);
      renderLists();
      alert(`${name} sacrificed for Soul Stone. Now choose someone to restore from Gone.`);
      highlightGone("restoreSoul");
      return;
    }
    lis.forEach(l=>l.classList.remove("highlight"));
    renderLists();
  });
}
function clearHighlights(){
  document.querySelectorAll("li").forEach(li=>{
    li.classList.remove("highlight");
    li.onclick = null;
  });
}

function highlightGone(purpose){
  const lis = document.querySelectorAll("#goneList li");
  lis.forEach(li=>li.classList.add("highlight"));
  lis.forEach(li=>li.onclick=function(){
    const name = this.dataset.name;
    const idx = gone.findIndex(p=>p.name===name);
    if(idx>-1){
      const restored = gone.splice(idx,1)[0];
      keepList.push({...restored,protected:false});
      renderLists();
      if(purpose==="restoreSoul") alert(`${restored.name} restored using Soul Stone!`);
      else alert(`${restored.name} restored using Reality Stone!`);
    }
    lis.forEach(l=>l.classList.remove("highlight"));
  });
}

// Shuffle helper
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} }

// End game
function endGame(){
  document.body.innerHTML = `<h1>üß§ Balance of the Gauntlet</h1>
<a href="index.html">Smash or Pass</a>
<a href="kmk.html">Kiss Marry Kill</a>
<a href="goc.html">Girl or Car</a>
<a href="blind.html">Blind Ranking</a>
<a href="wyw.html">King of the Hill</a>
<a href="chaos.html">Play Again</a>
<h2>Game Over</h2><h3>You Protected:</h3>`;
  keepList.forEach(p=>{
    document.body.innerHTML+=`<p>${p.name}${p.protected?" üõ°Ô∏è":""}</p>`;
  });
}

// Initial render
renderLists();
</script>

<div class="instructions">
<h3>Instructions</h3>
<ul>
<li>Keep up to 12 people in your "Keep" list. Going over the max will randomly remove someone.</li>
<li>Random Thanos snaps will remove half of unprotected keeps. Some keeps may be protected by stones.</li>
<li>Stones can only be used once each per game:</li>
  <ul>
    <li>‚è≥ Time Stone: Restores a random half from the last snap.</li>
    <li>üíÄ Soul Stone: Sacrifice a Keep to restore one from Gone.</li>
    <li>üåå Space Stone: Protect one Keep from the next snap.</li>
    <li>ü™û Reality Stone: Restore one person from Gone.</li>
  </ul>
<li>Click on names in Keep or Gone lists when using stones to select them.</li>
<li>The game ends when the pool is empty. Try to protect your favorites!</li>
</ul>
</div>
</body>
</html>
